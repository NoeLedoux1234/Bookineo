// Script de test pour toutes les APIs de la page d'accueil (Liste des Livres)
// Usage: node scripts/test-books-api.js

const BASE_URL = 'http://localhost:3000';

class BookAPITester {
  constructor() {
    this.testResults = [];
    this.createdBookId = null;
  }

  async log(message, isSuccess = true) {
    const status = isSuccess ? '‚úÖ' : '‚ùå';
    const logMessage = `${status} ${message}`;
    console.log(logMessage);
    this.testResults.push({
      message,
      success: isSuccess,
      timestamp: new Date(),
    });
  }

  async makeRequest(endpoint, options = {}) {
    try {
      const url = `${BASE_URL}${endpoint}`;
      console.log(`üîó ${options.method || 'GET'} ${endpoint}`);

      const response = await fetch(url, {
        headers: {
          'Content-Type': 'application/json',
          ...options.headers,
        },
        ...options,
      });

      const data = await response.json();

      if (!response.ok) {
        throw new Error(
          `HTTP ${response.status}: ${data.message || 'Erreur inconnue'}`
        );
      }

      return { response, data };
    } catch (error) {
      console.error(`‚ùå Erreur requ√™te ${endpoint}:`, error.message);
      throw error;
    }
  }

  async testGetBooks() {
    console.log('\nüìö === TEST: Liste des livres ===');
    try {
      const { data } = await this.makeRequest('/api/books');

      if (data.success && data.data) {
        await this.log(
          `Liste des livres r√©cup√©r√©e: ${data.data.total} livres trouv√©s`
        );
        await this.log(
          `Pagination: page ${data.data.page}/${data.data.totalPages}`
        );

        if (data.data.items && data.data.items.length > 0) {
          const book = data.data.items[0];
          const hasRequiredFields =
            book.title &&
            book.author &&
            book.category !== undefined &&
            book.status &&
            book.price !== undefined;

          if (hasRequiredFields) {
            await this.log(
              'Structure des livres correcte (titre, auteur, cat√©gorie, statut, prix)'
            );
          } else {
            await this.log('Structure des livres incompl√®te', false);
          }
        }
      } else {
        await this.log('R√©ponse liste des livres invalide', false);
      }
    } catch (error) {
      await this.log(`√âchec r√©cup√©ration liste: ${error.message}`, false);
    }
  }

  async testSearchAndFilters() {
    console.log('\nüîç === TEST: Recherche et filtres ===');

    // Test recherche par titre
    try {
      await this.makeRequest('/api/books?search=test');
      await this.log(`Recherche par titre fonctionnelle`);
    } catch (error) {
      await this.log(`Recherche par titre √©chou√©e: ${error.message}`, false);
    }

    // Test filtre par statut
    try {
      await this.makeRequest('/api/books?status=AVAILABLE');
      await this.log(`Filtre par statut fonctionnel`);
    } catch (error) {
      await this.log(`Filtre par statut √©chou√©: ${error.message}`, false);
    }

    // Test filtre par prix
    try {
      await this.makeRequest('/api/books?priceMin=5&priceMax=50');
      await this.log(`Filtre par prix fonctionnel`);
    } catch (error) {
      await this.log(`Filtre par prix √©chou√©: ${error.message}`, false);
    }

    // Test pagination
    try {
      const { data } = await this.makeRequest('/api/books?page=1&limit=5');
      if (data.data.limit === 5) {
        await this.log(`Pagination fonctionnelle`);
      } else {
        await this.log(`Pagination incorrecte`, false);
      }
    } catch (error) {
      await this.log(`Pagination √©chou√©e: ${error.message}`, false);
    }
  }

  async testCreateBook() {
    console.log('\n‚ûï === TEST: Cr√©ation de livre ===');
    try {
      const testBook = {
        title: 'Livre de Test API',
        author: 'Auteur Test',
        year: 2024,
        category: 'Test',
        price: 19.99,
        description: "Livre cr√©√© pour tester l'API",
      };

      const { data } = await this.makeRequest('/api/books', {
        method: 'POST',
        body: JSON.stringify(testBook),
      });

      if (data.success && data.data && data.data.id) {
        this.createdBookId = data.data.id;
        await this.log(`Livre cr√©√© avec succ√®s (ID: ${this.createdBookId})`);
      } else {
        await this.log("Cr√©ation de livre √©chou√©e - pas d'ID retourn√©", false);
      }
    } catch (error) {
      await this.log(`Cr√©ation de livre √©chou√©e: ${error.message}`, false);
    }
  }

  async testGetBookDetails() {
    console.log('\nüìñ === TEST: D√©tails du livre ===');
    if (!this.createdBookId) {
      await this.log('Pas de livre cr√©√© pour tester les d√©tails', false);
      return;
    }

    try {
      const { data } = await this.makeRequest(
        `/api/books/${this.createdBookId}`
      );

      if (data.success && data.data) {
        const book = data.data;
        const hasBasicInfo = book.title && book.author && book.category;
        const hasRentalsInfo = Array.isArray(book.rentals);
        const hasOwnerInfo = book.owner !== undefined;

        if (hasBasicInfo && hasRentalsInfo && hasOwnerInfo) {
          await this.log(
            'D√©tails du livre complets (infos de base + locations + propri√©taire)'
          );
        } else {
          await this.log('D√©tails du livre incomplets', false);
        }
      } else {
        await this.log('R√©ponse d√©tails livre invalide', false);
      }
    } catch (error) {
      await this.log(`R√©cup√©ration d√©tails √©chou√©e: ${error.message}`, false);
    }
  }

  async testUpdateBook() {
    console.log('\n‚úèÔ∏è === TEST: Modification de livre ===');
    if (!this.createdBookId) {
      await this.log('Pas de livre cr√©√© pour tester la modification', false);
      return;
    }

    try {
      const updateData = {
        title: 'Livre de Test API - Modifi√©',
        price: 25.99,
      };

      const { data } = await this.makeRequest(
        `/api/books/${this.createdBookId}`,
        {
          method: 'PUT',
          body: JSON.stringify(updateData),
        }
      );

      if (data.success && data.data) {
        await this.log('Livre modifi√© avec succ√®s');
      } else {
        await this.log('Modification de livre √©chou√©e', false);
      }
    } catch (error) {
      await this.log(`Modification de livre √©chou√©e: ${error.message}`, false);
    }
  }

  async testCategories() {
    console.log('\nüìÇ === TEST: Liste des cat√©gories ===');
    try {
      const { data } = await this.makeRequest('/api/books/categories');

      if (data.success && Array.isArray(data.data)) {
        await this.log(`Cat√©gories r√©cup√©r√©es: ${data.data.length} cat√©gories`);
      } else {
        await this.log('Liste des cat√©gories invalide', false);
      }
    } catch (error) {
      await this.log(
        `R√©cup√©ration cat√©gories √©chou√©e: ${error.message}`,
        false
      );
    }
  }

  async testAuthorsSearch() {
    console.log("\nüë§ === TEST: Recherche d'auteurs ===");
    try {
      const { data } = await this.makeRequest('/api/books/authors/search?q=au');

      if (data.success && Array.isArray(data.data)) {
        await this.log(
          `Recherche d'auteurs fonctionnelle: ${data.data.length} r√©sultats`
        );
      } else {
        await this.log("Recherche d'auteurs invalide", false);
      }
    } catch (error) {
      await this.log(`Recherche d'auteurs √©chou√©e: ${error.message}`, false);
    }
  }

  async testStats() {
    console.log('\nüìä === TEST: Statistiques ===');
    try {
      const { data } = await this.makeRequest('/api/books/stats');

      if (data.success && data.data) {
        const stats = data.data;
        const hasRequiredStats =
          typeof stats.total === 'number' &&
          typeof stats.available === 'number' &&
          typeof stats.rented === 'number';

        if (hasRequiredStats) {
          await this.log(
            `Statistiques correctes: ${stats.total} total, ${stats.available} disponibles, ${stats.rented} lou√©s`
          );
        } else {
          await this.log('Structure des statistiques incorrecte', false);
        }
      } else {
        await this.log('R√©ponse statistiques invalide', false);
      }
    } catch (error) {
      await this.log(
        `R√©cup√©ration statistiques √©chou√©e: ${error.message}`,
        false
      );
    }
  }

  async testExport() {
    console.log('\nüìÑ === TEST: Export CSV ===');
    try {
      const response = await fetch(`${BASE_URL}/api/books/export`);

      if (response.ok) {
        const contentType = response.headers.get('content-type');
        const contentDisposition = response.headers.get('content-disposition');

        if (contentType && contentType.includes('text/csv')) {
          await this.log('Export CSV - Type de contenu correct');
        } else {
          await this.log('Export CSV - Type de contenu incorrect', false);
        }

        if (contentDisposition && contentDisposition.includes('attachment')) {
          await this.log('Export CSV - En-t√™tes de t√©l√©chargement corrects');
        } else {
          await this.log(
            'Export CSV - En-t√™tes de t√©l√©chargement incorrects',
            false
          );
        }
      } else {
        await this.log(`Export CSV √©chou√©: HTTP ${response.status}`, false);
      }
    } catch (error) {
      await this.log(`Export CSV √©chou√©: ${error.message}`, false);
    }
  }

  async testDeleteBook() {
    console.log('\nüóëÔ∏è === TEST: Suppression de livre ===');
    if (!this.createdBookId) {
      await this.log('Pas de livre cr√©√© pour tester la suppression', false);
      return;
    }

    try {
      const { data } = await this.makeRequest(
        `/api/books/${this.createdBookId}`,
        {
          method: 'DELETE',
        }
      );

      if (data.success) {
        await this.log('Livre supprim√© avec succ√®s');
      } else {
        await this.log('Suppression de livre √©chou√©e', false);
      }
    } catch (error) {
      await this.log(`Suppression de livre √©chou√©e: ${error.message}`, false);
    }
  }

  async runAllTests() {
    console.log('üöÄ === D√âMARRAGE DES TESTS API BOOKS ===\n');
    console.log(`üîó URL de base: ${BASE_URL}`);

    await this.testGetBooks();
    await this.testSearchAndFilters();
    await this.testCreateBook();
    await this.testGetBookDetails();
    await this.testUpdateBook();
    await this.testCategories();
    await this.testAuthorsSearch();
    await this.testStats();
    await this.testExport();
    await this.testDeleteBook();

    this.generateReport();
  }

  generateReport() {
    console.log('\nüìã === RAPPORT FINAL ===');

    const totalTests = this.testResults.length;
    const successfulTests = this.testResults.filter((r) => r.success).length;
    const failedTests = totalTests - successfulTests;

    console.log(`üìä Tests total: ${totalTests}`);
    console.log(`‚úÖ R√©ussis: ${successfulTests}`);
    console.log(`‚ùå √âchou√©s: ${failedTests}`);
    console.log(
      `üìà Taux de r√©ussite: ${Math.round((successfulTests / totalTests) * 100)}%`
    );

    if (failedTests > 0) {
      console.log('\n‚ùå Tests √©chou√©s:');
      this.testResults
        .filter((r) => !r.success)
        .forEach((r) => console.log(`   - ${r.message}`));
    }

    if (successfulTests === totalTests) {
      console.log(
        '\nüéâ TOUS LES TESTS SONT PASS√âS ! Le backend est pr√™t pour le frontend.'
      );
    } else {
      console.log(
        '\n‚ö†Ô∏è Certains tests ont √©chou√©. V√©rifiez les erreurs ci-dessus.'
      );
    }
  }
}

// Lancer les tests
const tester = new BookAPITester();
tester.runAllTests().catch((error) => {
  console.error('‚ùå Erreur fatale lors des tests:', error);
  process.exit(1);
});
